---
layout: guide
title: Getting Started
authors: ['Dan Allen']
translators: ['Takayuki Konishi']
tags: [cdi, weld, maven, forge, eclipse]
guide_summary: プロジェクトのテストスイートへArquillianを追加し、最初のArquillianテストの書き方を学びます。
guide_group: 1
guide_order: 10
TODO: ["Explain how to debug w/ JBoss AS managed"]
---
[forge_home]http://jboss.org/forge
[forge_download]https://repository.jboss.org/nexus/service/local/artifact/maven/redirect?r=releases&g=org.jboss.forge&a=forge-distribution&v=1.0.0.Beta3&e=zip
[maven_home]http://maven.apache.org
[maven_download]http://maven.apache.org/download.html
[maven_search]http://search.maven.org
[jdk_download]http://www.oracle.com/technetwork/java/javase/downloads/jdk-6u29-download-513648.html
[as7_download]http://jboss.org/jbossas/downloads
[tools_home]http://jboss.org/tools
[shrinkwrap_home]http://jboss.org/shrinkwrap
[m2e_home]http://eclipse.org/m2e

このガイドではArquillianを紹介します。このガイドを読むと、以下のことができるようになります：

* MavenベースのJavaプロジェクトに、Arquillianインフラストラクチャを追加する
* CDI(Contexts and Dependency Injection) beanの振る舞いを検証するArquillianのテストケースを書く
* 複数の互換性のあるコンテナでArquillianのテストケースを実行する

これらのスキルを、ArquillianをJava EEアプリケーションのテストスイートとMavenのビルドに組み込むことで学びます。このガイドは、読者がさっと始められるように、 _速く読めるよう_ デザインされています！

h3. 前提

Arquillianを始める最も簡単なやり方は、依存性の管理をしているプロジェクトのテストスイートに組み込むことです。今日、このカテゴリで最も広く利用されているビルドツールは、 "Apache Maven":maven_home です。このガイドでは、サンプルのMavenプロジェクトを使って、最初の *(greenbar)グリーンバー* へ案内します。

p(info). %ArquillianはMavenには、もっと言えばどんな特定のビルドツールにも依存しません。それはAntやGradleでビルドするプロジェクトで使っても --より優れているとは言わないまでも-- 同じように機能します。理想的には、ビルドツールは、 "Maven Central repository":maven_search で配布されているArquillianライブラリをプロジェクトに追加するタスクを単純化できる、依存性管理を提供している物がいいでしょう。%

このガイドは、読者がコマンドシェルとIDE(Integrated Development Environment:統合開発環境)からMavenを利用できると仮定しています。もしそうでなければ、 "Mavenをインストールしてください":maven_download 。 また、 "JDK(Java Development Kit) 1.6":jdk_download 以降のインストールが必要です。

h3. 新しいプロジェクトを作成する

新しいプロジェクトを作成する際に、お勧めの方法が2つあります：

# "Maven archetypeからプロジェクトを生成する":#generate_project_from_archetype
# "JBoss Forgeでプロジェクトを作成、カスタマイズする":#create_project_using_forge

p(info). %既存のMavenプロジェクトがあれば、この章を、次章に進む前に正しい依存性の設定になっているかのレビューとして使うことができます。%

間違いなく、 "JBoss Forge":forge_home はより簡単なやり方ですが、このガイドではJBoss Forgeをまだ受け入れられないことを考慮して、両方のオプションを示します。上で示した二つのオプションからどちらかを選んで、次の説明に飛んでください。

h4(#generate_project_from_archetype). Maven Archetypeからプロジェクトを生成する

まず、以下のコマンドでMavenベースのJavaプロジェクトを生成します。 _@$@ 以降のテキストをコピーして、コマンドシェルにペーストしてください。_

bc(command).. $ mvn archetype:generate -DarchetypeGroupId=net.avh4.mvn.archetype \
-DarchetypeArtifactId=java-1.6-archetype

p. プロンプトでは、それぞれ、コロン2つの後に示している値を入力してください。（ @<ENTER>@ で示しているように）各行でエンターキーを押してください。

bc(output). Define value for property 'groupId': : org.arquillian.example <ENTER>
Define value for property 'artifactId': : arquillian-tutorial <ENTER>
Define value for property 'version': : <ENTER>
Define value for property 'package': : <ENTER>
Confirm properties configuration:
groupId: org.arquillian.example
artifactId: arquillian-tutorial
version: 1.0-SNAPSHOT
package: org.arquillian.example
Y: : <ENTER>

p. このコマンドは、カレントディレクトリに @arquillian-tutorial@ という新しいフォルダを作り、そこにMavenベースのJavaプロジェクトを生成します。このプロジェクトのファイル構成は、次のようになります：

(filetree)* src/
** main/
*** java/ - アプリケーションのすべてのJavaソースファイルをここに置きます。（Javaパッケージの下に置きます）
*** resources/ - アプリケーションの設定ファイルをここに置きます。
** test/
*** java/ - すべてのテスト用のJavaソースコードをここに置きます。（Javaパッケージの下に置きます）
*** resources/ - すべてのテスト用の設定ファイルをここに置きます。（例：arquillian.xml）
* pom.xml - Mavenのビルドファイルです。Mavenでどのようにプロジェクトをビルドするか定義します。

p(info). %このプロジェクトは、Arquillianがそれぞれ最低限要求するバージョンであるJava 6とJUnit 4.8を使用するようにあらかじめ設定されています。%

ジェネレータはまた、2つの @java@ フォルダの下に、 @org.arquillian.example@ というJavaパッケージを作成しています。 @java@ フォルダ直下ではなく、このパッケージの下にJavaソースファイルを置いてください。

p(warning). %Arquillianはまた、TestNG 5をサポートしています。しかしこのガイドでは、JUnitを使用します。%

さて、エディタで @pom.xml@ を開いてください。XMLファイルには、基本的なプロジェクト情報、ビルドセクション、依存セクションが含まれているのが分かります。 *JUnitより下の<dependency>要素は不要なので削除してください。*

編集が終わったら、以下のようになっているはずです（表示上、簡潔にしてあります）：

div(filename). pom.xml

bc(prettify).. <project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://maven.apache.org/POM/4.0.0
        http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.arquillian.example</groupId>
    <artifactId>arquillian-tutorial</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>
    <name>arquillian-tutorial</name>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>2.3.2</version>
                <configuration>
                    <source>1.6</source>
                    <target>1.6</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.8.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>

p. これからJava EE 6コンポーネントを書きます。そのため、Java EE 6 APIをクラスパスに追加する必要があります。そうすれば、これらのコンポーネントをコンパイルできます。

@pom.xml@ ファイルをもう一度開き、そのXMLフラグメントを @<dependencies>@ 要素の下に追加してください。追加後は、以下のようになります：

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependencies>
    <dependency>
        <groupId>org.jboss.spec</groupId>
        <artifactId>jboss-javaee-6.0</artifactId>
        <version>1.0.0.Final</version>
        <type>pom</type>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.8.1</version>
        <scope>test</scope>
    </dependency>
</dependencies>
<!-- clip -->

p(important). %Java EE APIアーティファクトを、 @javax:javaee-api@ と組み合わせて *使わない* ことを強くおすすめします。このバンドルは、メソッドの実装を省いたクラスが含まれているので、実行時に（テストの実行時でも）これがクラスパスに残っていた場合、アプリケーションは奇妙なAbsent Codeエラーを投げます。もっと背景を知りたい場合は、 "このFAQを読んでください":http://community.jboss.org/wiki/WhatsTheCauseOfThisExceptionJavalangClassFormatErrorAbsentCode 。%

p. プロジェクトの基本は準備できました！"プロジェクトをEclipseで開く":#open_project_in_eclipse に進んでください。コードを書きはじめます！

h4(#create_project_using_forge). Forgeでプロジェクトを生成する

"JBoss Forge":forge_home は、標準ベースの環境で高速アプリケーション開発をするためのコマンドシェルです。別の見方をすれば、ドーピングしたMaven Archetypeのようなものです。

Forgeのインストールは、比較的短い手順であり、このガイドでは、基礎を体験します。以下の、簡単なステップに従ってインストールしてください：

# "Forgeをダウンロード":forge_download し、ディスクに展開します。展開したフォルダを @$FORGE_HOME@ と呼びます。
  ホームディレクトリの @forge@ というフォルダに配布物を展開したと仮定します。
# @$FORGE_HOME/bin@ を（WindowsやLinux、Mac OSXの）パスに追加します。

Unixベースのオペレーティングシステムでは、Forgeをパスに追加するというのは、一般的には、ユーザの$HOME/.bashrcまたは、$HOME/.profileを編集することになります。以下の環境変数をセットしてください：

bc(command). $ export FORGE_HOME=$HOME/forge/
$ export PATH=$PATH:$FORGE_HOME/bin

p(info). %Windowsでは、“コントロールパネル”を開き、右クリックして“システムのプロパティ”をクリックします。“詳細設定”タブを開き、“環境変数”をクリックします。そして、これらの二つのエントリを追加します。展開した配布物をすべてのユーザーがアクセスできる場所に置いていない限り、ユーザー変数にForgeを設定することをおすすめします。%

これでForgeがインストール（つまり、展開）されたので、コマンドプロンプト（シェル）を開き、 @forge@ コマンドを実行してください：

bc(command).. $ forge
   _____                    
  |  ___|__  _ __ __ _  ___ 
  | |_ / _ \| `__/ _` |/ _ \  \\
  |  _| (_) | | | (_| |  __/  //
  |_|  \___/|_|  \__, |\___| 
                   |___/      
 
[no project] ~ $

p. これだけです！Forgeが起動しました。さあ、プロジェクトを作る時です。

Forgeシェル上で、新しいプロジェクトを生成するために、以下のコマンドを実行してください。これは、上で、Maven Archetypeで作成したプロジェクトとそっくりです：

bc(command). $ new-project --named arquillian-tutorial --topLevelPackage org.arquillian.example

p. このコマンドは、 @arquillian-tutorial@ という MavenベースのJavaプロジェクトをカレントディレクトリの新規フォルダの下に生成します。

Forgeが生成したこのプロジェクトのファイル構成を以下に示します：

(filetree)* src/
** main/
*** java/ - アプリケーションのすべてのJavaソースファイルをここに置きます。（Javaパッケージの下に置きます）
*** resources/ - アプリケーションの設定ファイルをここに置きます。
**** META-INF/
***** forge.xml - 空のForge設定ファイルです。
** test/
*** java/ - すべてのテスト用のJavaソースコードをここに置きます。（Javaパッケージの下に置きます）
*** resources/ - すべてのテスト用の設定ファイルをここに置きます。（例：arquillian.xml）
* pom.xml - Mavenのビルドファイルです。Mavenでどのようにプロジェクトをビルドするか定義します。

また、ForgeはプロジェクトフォルダをForgeシェルのカレントディレクトリにします。

bc(command). [arquillian-tutorial] arquillian-tutorial $ 

デフォルトでは、Forgeはプロジェクトに、Arquillianが最低限要求するバージョンである、Java 1.6を設定します。便利ですね。

次に追加する必要があるのは、Java EE APIです。以下の @project add-dependency@ コマンドでできます：

bc(command). $ project add-dependency org.jboss.spec:jboss-javaee-6.0:1.0.0.Final:pom:provided

また、Arquillianが最低限要求するバージョンである、JUnit 4.8をテストスコープの依存性として追加する必要があります：

bc(command). $ project add-dependency junit:junit:4.8.1:test

Forgeが生成したpom.xmlを以下に示します：

div(filename). pom.xml

bc(prettify).. <?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xsi:schemaLocation="
        http://maven.apache.org/POM/4.0.0
        http://maven.apache.org/xsd/maven-4.0.0.xsd"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.arquillian.example</groupId>
    <artifactId>arquillian-tutorial</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <dependencies>
        <dependency>
            <groupId>org.jboss.spec</groupId>
            <artifactId>jboss-javaee-6.0</artifactId>
            <version>1.0.0.Final</version>
            <type>provided</type>
            <scope>pom</scope>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.8.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <repositories>
      <repository>
          <id>JBOSS_NEXUS</id>
          <url>http://repository.jboss.org/nexus/content/groups/public</url>
      </repository>
    </repositories>
    <build>
        <finalName>arquillian-tutorial</finalName>
        <plugins>
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>2.3.2</version>
                <configuration>
                    <source>1.6</source>
                    <target>1.6</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

p(info). %Arquillianは、Mavenセントラルリポジトリで配布されていて、そのためpom.xmlのJBossパブリックリポジトリの記述は不要で、削除できます。しかしMavenセントラルでは入手できない他のJBossソフトウェアを取得するために必要になるかもしれないことは、覚えておいてください。%

p(warning). %もし、プロジェクトのpom.xmlにリポジトリを明記するのはアンチパターンだと考えるなら、settings.xmlでリポジトリをユーザーグローバルに友好にするために "この説明":http://community.jboss.org/wiki/MavenGettingStarted-Users を読んでください。%

p. プロジェクトの基本は準備できました！Eclipseでプロジェクトを開きましょう。コードを書きはじめます！

h3. プロジェクトをEclipseで開く

Javaプロジェクトで開発するときは、EclipseのようなIDEを使うでしょう。だから、Arquillianは、IDEフレンドリーに設計されています。つまり、型破りな変更をしなくてもArquillianテストをIDEから実行できます。IDEの利点をすぐに活用しましょう。

Eclipseの起動から始めます。これはMavenプロジェクトなので、プロジェクトを開くには  "Maven Integration for Eclipse":m2e_home (m2e)のインストールが必要です。もしまだインストールしていなければ、簡単な方法は、 "JBoss Tools":tools_home をインストールすることです。次のステップに従ってEclipseマーケットプレイス（Eclipseのアプリケーションストアのようなもの）からインストールしてください。

# メインメニューから、 @Help > Eclipse Marketplace...@ を選択
#  検索フィールドに"jboss tools"と入力し（引用符を除く）、Enterを押す
# JBoss Tools (Indigo)のインストールボタンをクリック
# インストールウィザードを完了して、再起動のプロンプトが表示されたら再起動する

JBoss Tools はJava EEアプリケーション開発の快適な環境を提供します。心配しないで、これはそんなに重いプラグインではありません。

しかし、余分なJBoss ToolsなしでMavenの統合をしたい場合は、下のステップに従ってください：

# メインメニューから、 @Help > Eclipse Marketplace...@ を選択
#  検索フィールドに"maven"と入力し（引用符を除く）、Enterを押す
# Maven Integration for Eclipseのインストールボタンをクリック
# インストールウィザードを完了して、再起動のプロンプトが表示されたら再起動する
# Maven Integration for Eclipse WTPについてステップを繰り返す

Maven Integrationプラグインをインストールしたら、以下のステップでプロジェクトを開きます：

# メインメニューから、 @File > Import...@ を選択
# input sourceフィールドで"existing maven"と入力する
# Existing Maven Projectsオプションを選択し、Nextボタンをクリックする
# Browse...ボタンをクリックする
# ファイルシステムでプロジェクトフォルダへ移動し、OKボタンをクリックする
# Finishボタンをクリックして、プロジェクトを開く

EclipseはMavenプロジェクトを認識し、プロジェクトナビゲータビューで開きます。プロジェクトを展開したら、次の画像と同様に見えるでしょう：

!/images/guides/arquillian_tutorial_eclipse_project.png!

これで、ついに本題にたどり着きました！

h3. コンポーネントを作る

Arquillianテストを書くために、テスト対象のコードが必要です。余計なものがないところでArquillianテストをどのように実行するか学ぶために、ビジネスコンポーネントの作成から始めましょう。だんだん複雑なシナリオに進みます。

IDEで、新しくJavaの @Greeter@ クラスを @org.arquillian.example@ パッケージに作成してください。内容を以下のように挨拶するロジックで置き換えてください：

div(filename). src/main/java/org/arquillian/example/Greeter.java

bc(prettify).. package org.arquillian.example;

import java.io.PrintStream;

/**
 * A component for creating personal greetings.
 */
public class Greeter {
    public void greet(PrintStream to, String name) {
        to.println(createGreeting(name));
    }

    public String createGreeting(String name) {
        return "Hello, " + name + "!";
    }
}

p. このクラスがCDI(Contexts and Dependency Injection) beanとして注入された際に、正しく振る舞うことを検証したいと考えています。もちろん、簡単にユニットテストを書くこともできます。しかしこのbeanは依存性注入やメッセージングのようなエンタープライズサービスを使用していて、コンテナ内で使用されなければならないということにしましょう（加えて、それに成長の機会を与えます ~;) ）。

このクラスをCDI beanとして使うために、@@Inject@ アノテーションでテストに注入します。これはArquillianテストを必要とします！つまり、Arquillian APIをプロジェクトに追加する時です！

h3. Arquillian APIを追加する

もう一度、プロジェクト直下にある @pom.xml@ をエディタで開きます。Mavenにどのバージョンのアーティファクトを使うかを示します。Arquillianの推移的な依存性のためのBOM(Bill of Materials)またはバージョンマトリックスをインポートするため、以下のXMLフラグメントを、 @<build>@ 要素の上に追加してください。

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.jboss.arquillian</groupId>
            <artifactId>arquillian-bom</artifactId>
            <version>1.0.0.Final</version>
            <scope>import</scope>
            <type>pom</type>
        </dependency>
    </dependencies>
</dependencyManagement>
<!-- clip -->

p. 次に、Arquillian-JUnitインテグレーションを加えるために、次のXMLフラグメントを最後の @<dependency>@ 要素の下に追加してください：

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependency>
    <groupId>org.jboss.arquillian.junit</groupId>
    <artifactId>arquillian-junit-container</artifactId>
    <scope>test</scope>
</dependency>
<!-- clip -->

p. Arquillian-JUnitインテグレーションアーティファクトは、また、ShrinkWrap APIをテストクラスパスに追加します。これらの全ライブラリは、JUnit Arquillianテストを書き、コンパイルする際に必要です。

p(info). %JUnitの代わりにTestNGを使うためには、Arquillian JUnitインテグレーションをArquillian TestNGインテグレーションで置き換えてください。%

p. ここまでで、pom.xmlになにか問題があれば、 "このgist":https://gist.github.com/1263892 からダウンロードできます。

*最初のArquillianテストを書く準備ができました！*

h3. Arquillianテストを書く

Arquillianテストは、すこし余分なフレアのある、単なるユニットテストのように見えます。IDEに戻りましょう。

p(warning). %もし"Project configuration is out of date with pom.xml"というメッセージが表示されたら、プロジェクトを再同期するために右クリックしてProject > Maven > Update Project Configurationを選択してください.%

src/test/javaにて、 @org.arquillian.example@ パッケージ以下に @GreeterTest@ という新しいJUnitテストケースを作成することから始めます。力仕事はほとんどArquillianがやるので、よくあるsetupとteardownメソッドは不要です。今のところ、次のようになります：

div(filename). src/test/java/org/arquillian/example/GreeterTest.java

bc(prettify).. package org.arquillian.example;

import org.junit.Assert;
import org.junit.Test;

public class GreeterTest {
    @Test
    public void should_create_greeting() {
        Assert.fail("Not yet implemented");
    }
}

p. では、フレアについてです。Arquillianテストケースは、以下の3点が必要です：

# クラスへの @@RunWith(Arquillian.class)@ アノテーションの付加
# @@Deployment@ でアノテートされ、ShrinkWrapアーカイブを返すスタティックメソッド
# @@Test@ でアノテートされた、少なくとも一つのメソッド

@@RunWith@ アノテーションは、JUnitに、Arquillianをテストコントローラとして使用することを伝えます。Arquillianはテストアーカイブ（つまり、マイクロデプロイメント）を受け取るために @@Deployment@ アノテーションのついたメソッドを探します。そしてマジックが起きて、それぞれの @@Test@ メソッドはコンテナ環境内で実行されます。

h4. テストアーカイブとは？

テストアーカイブの目的は、テストに必要なクラスとリソースを、クラスパスにあるそれ以外から隔離することです。通常のユニットテストとは異なり、Arquillianは単純にクラスパス上のすべてに手をつけることはしません。その代わり、テストに必要なもの（もしクラスパス上のすべてと決めれば、それかもしれません）だけを含めます。このアーカイブは、 "ShrinkWrap":shrinkwrap_home を使って定義されます。これはアーカイブ（つまり、jar、war、ear）作成用のJava APIです。マイクロデプロイメントストラテジーにより、明確にテストしたいクラスにフォーカスできます。その結果として、テストは無駄のない状態のまま保たれます。

p(info). %また、ShrinkWrapはアーティファクト（ライブラリ）の解決をサポートします。プログラム的に設定ファイルを作成し、テストアーカイブに追加します。ShrinkWrapのより詳細な説明は、 "ShrinkWrap introduction":/guides/shrinkwrap_introduction を参照してください。%

Arquillianのフレアをテストに加えましょう：

div(filename). src/test/java/org/arquillian/example/GreeterTest.java

bc(prettify).. package org.arquillian.example;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(Arquillian.class)
public class GreeterTest {

    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class)
            .addClass(Greeter.class)
            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }

    @Test
    public void should_create_greeting() {
        Assert.fail("Not yet implemented");
    }
}

p. ShrinkWrapを使って、Javaアーカイブ（jar）を定義しました。このアーカイブは、テスト対象の @Greeter@ クラスと、META-INFディレクトリ内にこのアーカイブでCDIを有効にするための空のbeans.xmlファイルを含みます。

ここでやるべきことは、テストメソッドの上で @Greeter@ インスタンスを直接フィールドに注入し、未実装のテストメソッドをそのbeanの振る舞いを検証するものに置き換えることです。読者に和んでもらえるように、コンソールにも挨拶を出力します。

div(filename). src/test/java/org/arquillian/example/GreeterTest.java

bc(prettify).. // clip
@Inject
Greeter greeter;

@Test
public void should_create_greeting() {
    Assert.assertEquals("Hello, Earthling!",
        greeter.createGreeting("Earthling"));
    greeter.greet(System.out, "Earthling");
}

p. 編集が終わったらどのようにテストがどうなっているかというと：

div(filename). src/test/java/org/arquillian/example/GreeterTest.java

bc(prettify).. package org.arquillian.example;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.Test;
import org.junit.Assert;
import org.junit.runner.RunWith;

@RunWith(Arquillian.class)
public class GreeterTest {

    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class)
            .addClass(Greeter.class)
            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }

    @Inject
    Greeter greeter;

    @Test
    public void should_create_greeting() {
        Assert.assertEquals("Hello, Earthling!",
            greeter.createGreeting("Earthling"));
        greeter.greet(System.out, "Earthling");
    }
}

p. 最初のArquillianテストが書けました！ああ、でもどのように動かすのか、疑問に思ってるかもしれませんね ~:S “ユニットテストみたいに”と思っているなら、それは正解です！しかし、クラスパスにコンテナアダプタを追加する必要があります。

h3. コンテナアダプタを追加する

これまで、コンテナでテストすることについて数多く語ってきましたが、今のところどれとは言及しませんでした。それは、実行時に決定することだからです。

Arquillianは、テストクラスパスで利用可能なコンテナの中からターゲットコンテナを選択します。だから、プロジェクトにもっとライブラリを追加します。

Arquillianのテストは、テストで使用するプログラミングモデルと互換性があるならば（コンテナ用のArquillianアダプタがあるならば）どんなコンテナでも実行できます。私達のテストは、CDIプログラミングモデルを使用しているので、CDIをサポートするコンテナを使う必要があります。開発中の高速なターンアラウンドが希望なので、Weld EEエンベデッドコンテナから始めましょう。

また、 @pom.xml@ を開き、他の @<dependency>@ 要素の下に、 以下の依存性のグループを追加してください：

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependency>
    <groupId>org.jboss.arquillian.container</groupId>
    <artifactId>arquillian-weld-ee-embedded-1.1</artifactId>
    <version>1.0.0.CR2</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.jboss.weld</groupId>
    <artifactId>weld-core</artifactId>
    <version>1.1.1.Final</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-simple</artifactId>
    <version>1.5.10</version>
    <scope>test</scope>
</dependency>
<!-- clip -->

p. まとめると、Arquillianを使うには、（JUnitと共に）以下の3つのライブラリが必要です：

# Arquillian JUnit インテグレーション
# ターゲットコンテナ向けのArquillianコンテナアダプタ
# コンテナのランタイム（エンベデッドコンテナ）または、コンテナのクライアント（リモートコンテナ）

このサンプルでは、エンベデッドコンテナを使っています。それで、コンテナのランタイムであるWeldが必要です。

さて、テストに戻ります。

h3. Arquillianテストの実行

Arquillianに必要なすべてのライブラリをクラスパスに追加したら、ユニットテストのようにArquillianテストを実行できます。IDEから実行することも、ビルドスクリプトやどんなテストプラグインから実行することもできます。Eclipseから実行してみましょう。

IDEのウィンドウから、Package Explorer（またはエディタ）のGreeterTest.javaを右クリックしてコンテキストメニューからRun As > JUnit Testを選択します。

!/images/guides/arquillian_tutorial_run_junit_test.png!

テストを実行したら、以下の行がコンソールに出力されるでしょう：

bc(output). 26 [main] INFO org.jboss.weld.Version - WELD-000900 1.1.1 (Final)
Hello, Earthling!

それから、JUnitビューが表示され、 *(greenbar)グリーンバー* が現れます！

!/images/guides/arquillian_tutorial_junit_green_bar.png!

コマンドラインから、Mavenでテストを実行することもできます：

bc(command). $ mvn test

以下の行がコンソールに出力されるでしょう：

bc(output). -------------------------------------------------------
T E S T S
-------------------------------------------------------
Running org.arquillian.example.GreeterTest
21 [main] INFO org.jboss.weld.Version - WELD-000900 1.1.1 (Final)
Hello, Earthling!
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.858 sec

*おめでとう！* Arquillianを使って、最初の*(greenbar)グリーンバー* に到達しました！

h3. 詳しく見る

CDIが実際にはどのように動作しているかわかりますか？わかっていることは、Arquillianは、 @Greeter@ クラスの新しいインスタンスを作成し、CDIとは無関係にテストに注入することだけです。そこを調べてみましょう。

@org.arquillian.example@ パッケージに @PhraseBuilder@ という新しいCDI beanを作成します。これは、テンプレートからフレーズを生成します。

div(filename). src/main/java/org/arquillian/example/PhraseBuilder.java

bc(prettify).. package org.arquillian.example;

import java.text.MessageFormat;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.PostConstruct;

public class PhraseBuilder {
    private Map<String, String> templates;

    public String buildPhrase(String id, Object... args) {
        return MessageFormat.format(templates.get(id), args);
    }

    @PostConstruct
    public void initialize() {
        templates = new HashMap<String, String>();
        templates.put("hello", "Hello, {0}!");
    }
}

p. 次に、 @Greeter@ クラスを開き、コンストラクタインジェクションを使って @PhraseBuilder@ を注入する、新しいコンストラクタを作成します。それから、挨拶を作るタスクを注入されたbeanに移譲します。

div(filename). src/main/java/org/arquillian/example/Greeter.java

bc(prettify).. package org.arquillian.example;

import java.io.PrintStream;
import javax.inject.Inject;

public class Greeter {

    private PhraseBuilder phraseBuilder;

    @Inject
    public Greeter(PhraseBuilder phraseBuilder) {
        this.phraseBuilder = phraseBuilder;
    }

    public void greet(PrintStream to, String name) {
        to.println(createGreeting(name));
    }

    public String createGreeting(String name) {
        return phraseBuilder.buildPhrase("hello", name);
    }
}

p. さて、テスト実行のために、 @PhraseBuilder@ のインスタンスが作成され、 その @@PostConstruct@ メソッドが実行され、 @Greeter@　のインスタンスが作成されるときに @Greeter@　のコンストラクタに注入されなければなりません。これらがすべてが起きれば、CDIが動作していることを確認できます。

p. 最後のステップです。新しいクラスを作ったので、テスト時に @@Deployment@ メソッド が返すアーカイブにそれを加える必要があります。簡単に、以下の行を変更してください：

bc(prettify).. .addClass(Greeter.class)

p. ...次のように：

bc(prettify).. .addClasses(Greeter.class, PhraseBuilder.class)

p. もう一度テストを実行してください。また、 *(greenbar)グリーンバー* が表示されます！気持ちいいでしょう？

h3. テストをデバッグする

これは短い章になるでしょう。なぜか？Arquillianのテストは、とても直接的なので、まさにユニットテストをデバッグするようにデバッグします。テストコードでも、アプリケーションコードでも、どこにでもブレークポイントを追加するだけです。それから、ファイルを右クリックして、Debug As > JUnit Testを選択します。これでコンテナでデバッグができます！楽しく調べ回ってください！

!/images/guides/arquillian_tutorial_debugging_test.png!

p(warning). %If you're using a remote container, Debug As does not cause breakpoints to be activated. Instead, you need to start the container in debug mode and attach the debugger. That's because the test is run in a different JVM than the original test runner.%

As you've just witnessed, Arquillian is the ideal tool for testing CDI applications. It takes care of loading the CDI environment and injecting beans directly into the test. Best of all, when using an embedded CDI container, the test runs just as quickly as a unit test. If that's all you need, then you can exit the tutorial now and start writing tests.

*But!* Is the embedded container telling the whole story? Will the component work if running inside a full container?

One of the perks of Arquillian is that you can run the same test in different compatible containers, whether it's another embedded container or a standalone container. If you intend to use multiple containers, read on.

h3. Add More Containers

As you learned earlier, Arquillian selects the container based on which container adapter is on the classpath. To switch to another container, you just change which container adapter is on the classpath before you run the test.

p(important). %There can only be one container adapter on the classpath at a given time.%

One way to swap the libraries on the classpath is to manually edit the dependencies defined in the @pom.xml@ each time. But that's just crazy. There's a much better way.

We can use Maven profiles to partition the dependencies into groups, one group for each container adapter and its related artifacts. When running the tests, you activate one of those groups to select the container using either a commandline flag (-P) or a preference in the IDE.

Open up the @pom.xml@ and create a new profile for Weld EE embedded by inserting the following XML directly under the @<dependencies>@ element:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profiles>
    <profile>
        <id>arquillian-weld-ee-embedded</id>
        <dependencies>
            <dependency>
                <groupId>org.jboss.spec</groupId>
                <artifactId>jboss-javaee-6.0</artifactId>
                <version>1.0.0.Final</version>
                <type>pom</type>
                <scope>provided</scope>
            </dependency>
            <dependency>
                <groupId>org.jboss.arquillian.container</groupId>
                <artifactId>arquillian-weld-ee-embedded-1.1</artifactId>
                <version>1.0.0.CR2</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.jboss.weld</groupId>
                <artifactId>weld-core</artifactId>
                <version>1.1.1.Final</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-simple</artifactId>
                <version>1.5.10</version>
                <scope>test</scope>
            </dependency>
        </dependencies>
    </profile>
</profiles>
<!-- clip -->

p. Next, *remove* the @jboss-javaee-6.0@ dependency and the dependencies for the Weld EE embedded container adapter from the main @<dependencies>@ section. Here's how the @<dependencies>@ and @<profiles>@ sections should look when you're done:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependencies>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.8.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.jboss.arquillian.junit</groupId>
        <artifactId>arquillian-junit-container</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
<profiles>
    <profile>
        <id>arquillian-weld-ee-embedded</id>
        <dependencies>
            <dependency>
                <groupId>org.jboss.spec</groupId>
                <artifactId>jboss-javaee-6.0</artifactId>
                <version>1.0.0.Final</version>
                <type>pom</type>
                <scope>provided</scope>
            </dependency>
            <dependency>
                <groupId>org.jboss.arquillian.container</groupId>
                <artifactId>arquillian-weld-ee-embedded-1.1</artifactId>
                <version>1.0.0.CR2</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.jboss.weld</groupId>
                <artifactId>weld-core</artifactId>
                <version>1.1.1.Final</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-simple</artifactId>
                <version>1.5.10</version>
                <scope>test</scope>
            </dependency>
        </dependencies>
    </profile>
</profiles>
<!-- clip -->

p(info). %The Java EE API dependency has been moved to the profile since some containers, like Embedded GlassFish, already provide these libraries. Having both on the classpath at the same time would result in conflicts. So we have to play this classpath dance.%

We'll now include two additional profiles in the @pom.xml@ inside the @<profiles>@ element, the first for "Embedded GlassFish":http://embedded-glassfish.java.net:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profile>
    <id>arquillian-glassfish-embedded</id>
    <dependencies>
        <dependency>
            <groupId>org.jboss.arquillian.container</groupId>
            <artifactId>arquillian-glassfish-embedded-3.1</artifactId>
            <version>1.0.0.CR1</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.glassfish.extras</groupId>
            <artifactId>glassfish-embedded-all</artifactId>
            <version>3.1</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>
</profile>
<!-- clip -->

p. and the other for JBoss AS managed:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profile>
    <id>arquillian-jbossas-managed</id>
    <dependencies>
        <dependency>
            <groupId>org.jboss.spec</groupId>
            <artifactId>jboss-javaee-6.0</artifactId>
            <version>1.0.0.Final</version>
            <type>pom</type>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.jboss.as</groupId>
            <artifactId>jboss-as-arquillian-container-managed</artifactId>
            <version>7.0.2.Final</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</profile>
<!-- clip -->

p. Now you have the choice of running the tests in one of three containers.

p. If you're having trouble with the pom.xml up to this point, you can download the file from "this gist":https://gist.github.com/1263934.

h3. Test Across Containers

When you refresh the project in Eclipse, you'll notice that it no longer builds. That's because you need to activate one of the container profiles. Let's activate the Weld EE embedded profile to restore the previous state.

There are two ways to activate a Maven profile in Eclipse:

# Manual configuration (standard approach)
# Maven profile selector (JBoss Tools)

h4. Set active Maven profile: Manual configuration

To set the active profile manually, follow these steps:

# Right click on the project and select Properties
# Select the Maven properties tab
# Enter the profile id in the Active Maven Profiles field (e.g., @arquillian-weld-ee-embedded@)
# Click the OK button and accept the project changes

Here's the Maven properties screen showing the profile we've activated:

!/images/guides/arquillian_tutorial_maven_properties.png!

h4. Set active Maven profile: Maven profile selector

If you have JBoss Tools installed, selecting the active profile becomes much easier:

# Right click on the project and select Maven > Select Active Profiles...
(alternatively, you can use the keybinding Ctrl+Shift+P or the button in the toolbar)
# Check the box next to the profile you want to activate (e.g., @arquillian-weld-ee-embedded@)
# Click the OK button

Here's the Maven profile selector dialog showing the profile we've activated:

!/images/guides/arquillian_tutorial_maven_profile_selector.png!

Once you've activate the profile, you should be able to run the test again successfully.

You already know the test works in Weld EE Embedded. Let's switch to GlassFish embedded by repeating the steps above, this time activating only the @arquillian-glassfish-embedded@ profile. Run the test again. You should see GlassFish start in the console...and another *(greenbar)green bar*!

You've now run the same test on two different embedded containers, a CDI container (Weld) and a Java EE container (GlassFish). Both of these executions are in process. To really be sure the component works in a pure environment, we need to use a standalone container. Let's switch to using JBoss AS.

To run the test on a standalone instance of JBoss AS, you first need to set it up. You can either:

# download and unpack it in a location outside the project or
# you can have Maven download and unpack it during a build.

Follow these steps to setup JBoss AS 7 outside the project:

# "Download JBoss AS 7":as7_download
(be sure the version you select matches the version you've defined in your @pom.xml@ for @<artifactId>jboss-as-arquillian-container-managed</artifactId>@)
# Extract the archive
# (optional) Set the @JBOSS_HOME@ environment variable to the path of the extracted directory

To have Maven handle this task for you instead, add the following XML fragment under the @<id>@ element of the @arq-jbossas-managed@ profile:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<build>
    <plugins>
        <plugin>
            <artifactId>maven-dependency-plugin</artifactId>
            <executions>
                <execution>
                    <id>unpack</id>
                    <phase>process-test-classes</phase>
                    <goals>
                        <goal>unpack</goal>
                    </goals>
                    <configuration>
                        <artifactItems>
                            <artifactItem>
                                <groupId>org.jboss.as</groupId>
                                <artifactId>jboss-as-dist</artifactId>
                                <version>7.0.2.Final</version>
                                <type>zip</type>
                                <overWrite>false</overWrite>
                                <outputDirectory>target</outputDirectory>
                            </artifactItem>
                        </artifactItems>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build> 
<!-- clip -->

p. To target a managed JBoss AS 7 instance, you also need a small bit of Arquillian configuration. Create the following configuration file and assign the value of the @jbossHome@ property to the location where JBoss AS 7 is installed. If you're using the Maven dependency plugin, the location is @target/jboss-as-7.0.2.Final@.

div(filename). src/test/resources/arquillian.xml

bc(prettify).. <arquillian xmlns="http://jboss.org/schema/arquillian"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://jboss.org/schema/arquillian
        http://jboss.org/schema/arquillian/arquillian_1_0.xsd">
    <container qualifier="jbossas-7-managed" default="true">
        <configuration>
            <property name="jbossHome">target/jboss-as-7.0.2.Final</property>
        </configuration>
    </container>
</arquillian>

p. Now change the active Maven profile to @arquillian-jbossas-managed@, then run the test again. You should see JBoss AS starting in the console...and yet another *(greenbar)green bar*!

p(info). %The message printed to System.out gets written to the server log instead of the console.%

That's the _same_ test, this time running in a standard (non-embedded) Java EE container. Arquillian packages the test, deploys to the container as a Java EE archive, executes the tests remotely, captures the results and feeds them back to the Eclipse JUnit result view (or in the Maven surefire results). You can read more about how this lifecycle works in the "Arquillian reference guide":https://docs.jboss.org/author/display/ARQ/Negotiating+test+execution.
