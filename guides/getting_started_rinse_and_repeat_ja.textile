---
layout: guide
title: "Getting Started: Rinse and Repeat"
authors: ['Dan Allen']
guide_summary: スタートガイドのパート２です。もう少し複雑な例を通じて、理解を確認し、リモートのコンテナをどのように使うか学びます。
guide_group: 1
guide_order: 20
TODO: ["ポートの設定と、arquillian.launch", "予想されたデプロイエラー"]
---
この "Getting Started":/guides/getting_started ガイドの続編では、少し複雑な例を通じて、Arquillianについて何を学んだかを確認できます。このガイドを読むと、以下のことができるようになります：

* CDI(Contexts and Dependency Injection)とEJB(Enterprise JavaBeans)を含むArquillianのテストを書く
* Arquillianのテストをリモートのコンテナ(つまり、サーバー)で実行する
* Arquillianのテストをリモートのコンテナ内でデバッグする

読者は、追加のプロファイルを有効にした際、Arquillianがリモートのコンテナ（つまり、サーバー）でテストを実行するためのビルドに組み込むことにより、これらの技術を学びます。これは、 _本物_ でのテストを意味します。モックではありません。組み込みのランタイムではありません！読者は、最初のガイドでもっとも厳しい作業は行っており、理解するまでさほど時間はかからないでしょう。

h3. 前提

このガイドは、読者がArquillianインフラストラクチャをテストスイートに追加済みで、少なくとも1つのをArquillianテストを書きいたことがあることを前提としています。これらがまだであれば、Arquillianの基本に親しむために "Getting Started":/guides/getting_started を読んでください。また、そのガイド内で必須となっているソフトウェアも必要です。

h3. コンポーネントを作成する

このガイドでは、とても基本的なショッピングアプリケーションのバックエンドを作成します。訪問者が選んだ品物を保存するためにbasketコンポーネントを使い、確定した注文を保存し読み出すためにorder repositoryコンポーネントを使います。ここでは、それぞれをCDIとEJBを使って実装します。すでにJava EE 6 APIがクラスパス上にあるので、すぐにこれら二つのプログラミングモデルを利用して始めることができます（このAPIをプロジェクトに導入する手順は、 "Getting Started":/guides/getting_started ガイドを参照してください）。

オーダーを永続的なストレージとやりとりするコンポーネントから始めましょう。よいソフトウェア設計に従い、またテストをシンプルにするために、契約を表すインターフェースの設計から始めます。IDEで、新しく @OrderRepository@ というローカルEJBインターフェースを作成し、以下のコンテンツを追加してください。

div(filename). src/main/java/org/arquillian/example/OrderRepository.java

bc(prettify).. package org.arquillian.example;

import java.util.List;
import javax.ejb.Local;

@Local
public interface OrderRepository {
    void addOrder(List<String> order);
    List<List<String>> getOrders();
    int getOrderCount();
}

p. 実装について気にするのは、ちょっと後にして、ここでは、この契約をどのように利用するか考えましょう。

訪問者がこのサイトを訪れたとき、買い物かごに品物を入れてから購入するでしょう。このシナリオをモデル化するために、訪問者のHTTPセッションに関連したCDI beanを使います。訪問者が選んだ品物を購入するときに、このコンポーネントは、 @OrderRepository@ EJBに移譲します。

IDEで、 @Basket@ というクラスを作成し、次に示すように @@SessionScoped@ スコープアノテーションを追加して、セッションコンテキストに割り当ててください。

div(filename). src/main/java/org/arquillian/example/Basket.java

bc(prettify).. package org.arquillian.example;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javax.annotation.PostConstruct;
import javax.ejb.EJB;
import javax.enterprise.context.SessionScoped;

@SessionScoped
public class Basket implements Serializable {
    private static final long serialVersionUID = 1L;
    private List<String> items;
    
    @EJB
    private OrderRepository repo;
    
    public void addItem(String item) {
        items.add(item);
    }
    
    public List<String> getItems() {
        return Collections.unmodifiableList(items);
    }
    
    public int getItemCount() {
        return items.size();
    }
    
    public void placeOrder() {
        repo.addOrder(items);
        items.clear();
    }
    
    @PostConstruct
    void initialize() {
        items = new ArrayList<String>();
    }
}

p. ご覧のようにEJBをCDI beanに接合しました。まさにテストしたいと考えている結合です！

h3. 段階的に実装する

まだまだテストを書く準備ができていません。それは @OrderRepository@ の実装がないからです。この例の目的のために、 @OrderRepository@ は、他のチーム（または別のイテレーション）の実装があると仮定しましょう。ここが、Arquillianのマイクロデプロイメント機能が本当に引き立つところです。EJBシングルトンとして、インメモリ実装を作成し、テストアーカイブにまとめて、動作するアプリケーションを短期間で手に入れることができます（この実装を、この境界でのテストのために残すと決めてしまうかもしれません）。

@SingletonOrderRepository@ クラスをテストクラスパス内に作成し、以下のコードを追加してください。

div(filename). src/test/java/org/arquillian/example/SingletonOrderRepository.java

bc(prettify).. package org.arquillian.example;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javax.annotation.PostConstruct;
import javax.ejb.Lock;
import javax.ejb.LockType;
import javax.ejb.Singleton;

@Singleton
@Lock(LockType.READ)
public class SingletonOrderRepository implements OrderRepository {
    private List<List<String>> orders;
    
    @Override
    @Lock(LockType.WRITE)
    public void addOrder(List<String> order) {
        orders.add(order);
    }
    
    @Override
    public List<List<String>> getOrders() {
        return Collections.unmodifiableList(orders);
    }
    
    @Override
    public int getOrderCount() {
        return orders.size();
    }
    
    @PostConstruct
    void initialize() {
        orders = new ArrayList<List<String>>();
    }
}

p. この実装にはおまけが追加されており、それはArquillianのサンドボックスの中で、EJB 3.1の新しいシングルトン機能で遊んでみる機会です。そんなわけで、筆者は、Arquillianはテストツールに加えて学習環境である、と言っています。

Arquillianテストを書く準備ができました。

h3. テストを書く

ここでは、 @Basket@ インスタンスへのアイテム追加を模倣し、そのインスタンスをあるオーダーに入れ、そのオーダーが処理され、一つの @OrderRepository@ インスタンスにストアされることを検証する テストを書こうとしています。

p(info). %いうまでもなく、ここでは、ただメモリ上での実装をテストします。データベースを使うテストをどのように書くかは、 "Testing Java Persistence":/guides/testing_java_persistence ガイドで学びます。%

@BasketTest@ クラスを作成し、Arquillianテストケースとして初期化します：

div(filename). src/test/java/org/arquillian/example/BasketTest.java

bc(prettify).. package org.arquillian.example;

import org.jboss.arquillian.junit.Arquillian;

@RunWith(Arquillian.class)
public class BasketTest {
}

p. 次に、basket、order repositoryインターフェースとそのシングルトン実装を含むテストアーカイブを定義します。また、CDIを有効にするため、空のbeans.xmlが必要です（EJBは自動的に有効化されます）。アーカイブに何を入れるかを厳密に定義することにより、いかにクラスパス以上に完全なコントールができているか、ということに注目してください。

div(filename). src/test/java/org/arquillian/example/BasketTest.java

bc(prettify).. package org.arquillian.example;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.jboss.shrinkwrap.api.spec.JavaArchive;

@RunWith(Arquillian.class)
public class BasketTest {
    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class, "test.jar")
            .addClasses(Basket.class, OrderRepository.class, SingletonOrderRepository.class)
            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }
}

p. 残りは、basketとorder repositoryを注入することと、それらのインタラクションをテストすることです。EJBは、実装ではなくインターフェースを注入します。EJBコンテナは、自動的にそのインターフェースで使用するEJB実装を見つけます。

div(filename). src/test/java/org/arquillian/example/BasketTest.java

bc(prettify).. package org.arquillian.example;

import javax.ejb.EJB;
import javax.inject.Inject;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(Arquillian.class)
public class BasketTest {
    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class, "test.jar")
            .addClasses(Basket.class, OrderRepository.class, SingletonOrderRepository.class)
            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }
    
    @Inject
    Basket basket;
    
    @EJB
    OrderRepository repo;
    
    @Test
    public void place_order_should_add_order() {
        basket.addItem("sunglasses");
        basket.addItem("suit");
        basket.placeOrder();
        Assert.assertEquals(1, repo.getOrderCount());
        Assert.assertEquals(0, basket.getItemCount());
        
        basket.addItem("raygun");
        basket.addItem("spaceship");
        basket.placeOrder();
        Assert.assertEquals(2, repo.getOrderCount());
        Assert.assertEquals(0, basket.getItemCount());
    }
    
    @Test
    public void order_should_be_persistent() {
        Assert.assertEquals(2, repo.getOrderCount());
    }
}

p. テストを書きました。次に実行するためにセットアップしなければなりません。

h3. リモートコンテナを追加する

このテストでは、CDIとEJBの両方を使用します。この組み合わせは、組み込みランタイム（たとえばWeld EmbeddedやOpenEJB Embedded）の限界を押し上げます。可能であったとしても、単純にJava EEコンテナを利用する方がシンプルです。それに加えて、より正確なテスト結果を得られます。それで、この後はWeld Embeddedコンテナから離れましょう。

前のガイドで、embeddedとmanagedの両方のコンテナを使いました。両方のケースで、Arquillianは、テストスイート開始時にコンテナをスタートし、テストが終了すると停止しなければなりません。コンテナをすでにスタートしていた場合（あるいはテストのために起動したい場合）はどうでしょう？ これは、明らかにテストの実行には最速です。コンテナの起動が非常に速いとしても、セットアップが不要な場合にはかないません。これがリモートコンテナの目的です。

リモートコンテナは、統合テストにおいて理想的な開発環境を提供します。また、とても直感的にデバッグができることに気づくでしょう。そして、テストにおいてコンテナへの参照がないので、開発時にリモートコンテナを使うと、継続的結合においてマネージドコンテナを利用する際に邪魔になりません。

p(warning). %リモートという用語は、異なるプロセスを意味します。他のマシンでも設定できますが、必ずしもその必要はありません。%

リモートコンテナは独立したプロセスで、Arquillianは、そのコンテナのクライアントのデプロイメントAPIを使用します。従って必要なライブラリは：

* プログラミングモデルのAPI（コンテナが提供しない場合に限り、パッケージ化するために必要です）
* Arquillianリモートコンテナアダプター
* コンテナプロセスと通信するためのクライアントデプロイメントAPI

Mavenのpom.xmlファイルの @<profiles>@ 要素の下に、新しいプロファイルを2つ加えてください。最初のプロファイルは、リモートのJBoss AS 7コンテナを使用します：

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profile>
    <id>arquillian-jbossas-remote</id>
    <dependencies>
        <dependency>
            <groupId>org.jboss.spec</groupId>
            <artifactId>jboss-javaee-6.0</artifactId>
            <version>1.0.0.Final</version>
            <type>pom</type>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.jboss.as</groupId>
            <artifactId>jboss-as-arquillian-container-remote</artifactId>
            <version>7.0.2.Final</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</profile>
<!-- clip -->

p. 二番目のプロファイルは、リモートのGlassFish 3.1コンテナを使用します：

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profile>
    <id>arquillian-glassfish-remote</id>
    <dependencies>
        <dependency>
            <groupId>org.jboss.spec</groupId>
            <artifactId>jboss-javaee-6.0</artifactId>
            <version>1.0.0.Final</version>
            <type>pom</type>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.jboss.weld</groupId>
            <artifactId>weld-api</artifactId>
            <version>1.0-SP1</version>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>javax.enterprise</groupId>
                    <artifactId>cdi-api</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>com.sun.jersey</groupId>
            <artifactId>jersey-bundle</artifactId>
            <version>1.6</version>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>javax.ws.rs</groupId>
                    <artifactId>jsr311-api</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>com.sun.jersey.contribs</groupId>
            <artifactId>jersey-multipart</artifactId>
            <version>1.6</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.jboss.arquillian.container</groupId>
            <artifactId>arquillian-glassfish-remote-3.1</artifactId>
            <version>1.0.0.CR2</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</profile>
<!-- clip -->

p(info). %The remote GlassFish adapter uses Jersey to communicate with the container via JAX-RS (REST) and thus requires these additional libraries. The Weld API is required for unmarshalling exceptions returned by the container process.%

Once you've added the profiles to the pom.xml, right click on the project in Eclipse and select Maven > Update Project Configuration. If the project is showing compiler errors, you need to activate one of the profiles.

Recall that there are two ways to activate a Maven profile in Eclipse:

# Manual configuration (standard approach)
# Maven profile selector (JBoss Tools)

Refer to the "Getting Started":/guides/getting_started#test_across_containers for instructions on how to activate a profile. Once you've activate the profile, the project should compile cleanly.

Arquillian is expecting the container to be running. Therefore, let's get them setup so that we can start them from the comfort of the IDE right before we run the test.

h3. Control the Servers

The easiest way to manage the remote containers is to set them up in your IDE. If you're a more of a commandline person, you can skip this step and start the servers using the appropriate startup scripts.

We'll show you how to add the server (container) controls in Eclipse. The process is similar for other IDEs. For Eclipse, you'll need both "JBoss Tools":http://jboss.org/tools and the GlassFish Java EE Application Server Plugin, both of which are available in the Eclipse MarketPlace.

In Eclipse, select Window > Show View > Servers from the main menubar. Once the view opens, right click and select New > Server. You'll want to define one server for JBoss AS 7 and one for GlassFish 3.1. For JBoss AS 7, the wizard requires that you have already downloaded and extracted the JBoss AS 7 runtime. The GlassFish 3.1 wizard gives you the option of downloading the distribution automatically.

!/images/guides/arquillian_tutorial_2_new_jbossas_server.png!

!/images/guides/arquillian_tutorial_2_new_glassfish_server.png!

Once you have completed the wizard for each container, you should see them appear in the server view.

!/images/guides/arquillian_tutorial_2_servers_view.png!

To start a server, select the entry (as shown in the graphic above) and click the green play icon.

p(info). %Arquillian assumes the containers are running on their default ports. If you have changed the ports, you can use arquillian.xml to specify the ports you are using for each container.%

Now that you've got the containers ready and waiting, it's time to fire the test off to them.

h3. Run the Arquillian Test

To run the Arquillian test, you need to perform three steps:

# Start the remote container
# Activate the Maven profile that adds the cooresponding container adapter to the classpath
# Run the test

Let's start by using JBoss AS 7.

h4. Run the Test on JBoss AS

To run the test on JBoss AS, begin by starting the JBoss AS container. Open the Servers view, select JBoss AS 7, then click the green play button. Wait for it to start (it shouldn't take long).

Once that's up and running, activate the @arquillian-jbossas-remote@ Maven profile using either the Maven properties tab or the JBoss Tools Maven profile selector. The profile editor below shows the correct selection.

!/images/guides/arquillian_tutorial_2_jbossas_profile_selection.png!

Finally, right click on the @BasketTest@ class and select Run As > JUnit Test. You should see a flurry of activity in the Console view and a successful result in the JUnit view.

You can also run the test on the commandline using Maven:

bc(command). $ mvn test -Parquillian-jbossas-remote -Dtest=BasketTest

You should see the following lines printed to the console:

bc(output). -------------------------------------------------------
T E S T S
-------------------------------------------------------
Running org.arquillian.example.BasketTest
...
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.464 sec

*Congratulations!* You've earned your first *(greenbar)green bar* with Arquillian using a remote container.

p(info). %You can also inject the EJB using @@Inject@ rather than @@EJB@. Give it a try!%

If you want to verify that the singleton is actually doing its job, go ahead and remove the @@Singleton@ annotation from the @SingletonOrderRepository@ class. You should see an assertion error when you run the test. Restore it and you'll be back to green.

Now let's test the exact same test on GlassFish 3.1. Since we are done with JBoss AS for the moment, use the Servers view to stop the server.

h4. Run the Test on GlassFish

To run the test on GlassFish, begin by starting the GlassFish container. Open the Servers view, select GlassFish 3.1, then click the green play button. Wait for it to start.

Once that's up and running, activate the @arquillian-glassfish-remote@ Maven profile using either the Maven properties tab or the JBoss Tools Maven profile selector. Remember to deactivate the @arquillian-jbossas-remote@ profile. The profile editor below shows the correct selection.

!/images/guides/arquillian_tutorial_2_glassfish_profile_selection.png!

Finally, right click on the @BasketTest@ class and select Run As > JUnit Test. You should see a flurry of activity in the Console view and a successful result in the JUnit view.

*Congratulations!* You've earned another *(greenbar)green bar*.

h3. Debug the Arquillian Test

Debugging a test in a remote container? That seems hard. Surprise! It's not at all. You only have to modifiy one of the step above and add one additional step:

# *Debug* the remote container
# Activate the Maven profile that adds the cooresponding container adapter to the classpath
# *Set a breakpoint*
# Run the test

In the Servers view, you should notice that there is a bug icon right next to the green play button. Click this button to start one of the servers in debug mode. Eclipse automatically connects its debugger to the container.

Set a breakpoint in the @addOrder()@ method on the @SingletonOrderRepository@ bean. Now, run the test again by right clicking and selecting Run As > JUnit Test.

p(warning). %You don't need to use Debug As > JUnit Test since all the test code is running inside the container, which is already being debugged.%

The test should halt at the breakpoint. If you are using JBoss AS, you can open the administration console and verify that the test application is currently deployed to the server. If you browse the stack trace in the Eclipse Debug view, you'll notice that the server is being controlled over a remote protocol (either JMX or Servlet) and that JUnit is being launched from inside the container.

!/images/guides/arquillian_tutorial_2_debug_remote_test.png!

You are now poking around the server from the comfort of your IDE.
